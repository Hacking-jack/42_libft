=== LIBFT COMPREHENSIVE TEST ===

=== TESTING ft_isalpha ===
--- Letters ---
'a': ft=1, std=1024 -> FAIL
'B': ft=1, std=1024 -> FAIL
'c': ft=1, std=1024 -> FAIL
'D': ft=1, std=1024 -> FAIL
'e': ft=1, std=1024 -> FAIL
'F': ft=1, std=1024 -> FAIL
'z': ft=1, std=1024 -> FAIL
'Z': ft=1, std=1024 -> FAIL

--- Non-letters ---
'0': ft=0, std=0 -> PASS
'@': ft=0, std=0 -> PASS
' ': ft=0, std=0 -> PASS
'7': ft=0, std=0 -> PASS
'!': ft=0, std=0 -> PASS

=== TESTING ft_isdigit ===
'0': ft=48, std=2048 -> FAIL
'1': ft=49, std=2048 -> FAIL
'2': ft=50, std=2048 -> FAIL
'3': ft=51, std=2048 -> FAIL
'4': ft=52, std=2048 -> FAIL
'5': ft=53, std=2048 -> FAIL
'6': ft=54, std=2048 -> FAIL
'7': ft=55, std=2048 -> FAIL
'8': ft=56, std=2048 -> FAIL
'9': ft=57, std=2048 -> FAIL

=== TESTING ft_isalnum ===
'a': ft=1, std=8 -> FAIL
'1': ft=1, std=8 -> FAIL
'!': ft=0, std=0 -> PASS
' ': ft=0, std=0 -> PASS

=== TESTING ft_isascii ===
-1: ft=0, std=0 -> PASS
32: ft=1, std=1 -> PASS
65: ft=1, std=1 -> PASS
98: ft=1, std=1 -> PASS

=== TESTING ft_isprint ===
0: ft=0, std=0 -> PASS
10: ft=0, std=0 -> PASS
20: ft=0, std=0 -> PASS
30: ft=0, std=0 -> PASS
40: ft=1, std=16384 -> FAIL
50: ft=1, std=16384 -> FAIL
60: ft=1, std=16384 -> FAIL
70: ft=1, std=16384 -> FAIL
80: ft=1, std=16384 -> FAIL
90: ft=1, std=16384 -> FAIL
100: ft=1, std=16384 -> FAIL
110: ft=1, std=16384 -> FAIL
120: ft=1, std=16384 -> FAIL

=== TESTING ft_strlen ===
'' -> ft=0 std=0 -> PASS
'a' -> ft=1 std=1 -> PASS
'Hello World' -> ft=11 std=11 -> PASS
'Long string to test length on and on...' -> ft=39 std=39 -> PASS

=== TESTING ft_memset ===
memset: PASS

=== TESTING ft_bzero ===
bzero: PASS

=== TESTING ft_memcpy ===
memcpy: PASS

=== TESTING ft_memmove ===
memmove: PASS

=== TESTING ft_strlcpy ===
ft_strlcpy returned 10, buffer: 'Hello'
strlcpy:    returned 10, buffer: 'Hello'

=== TESTING ft_strlcat ===
ft_strlcat returned 10, buffer: 'HelloWorld'
strlcat:    returned 10, buffer: 'HelloWorld'

=== TESTING ft_toupper ===
0 -> ft=0 std=0 [PASS]
13 -> ft=13 std=13 [PASS]
26 -> ft=26 std=26 [PASS]
39 -> ft=39 std=39 [PASS]
52 -> ft=52 std=52 [PASS]
65 -> ft=65 std=65 [PASS]
78 -> ft=78 std=78 [PASS]
91 -> ft=91 std=91 [PASS]
104 -> ft=72 std=72 [PASS]
117 -> ft=85 std=85 [PASS]

=== TESTING ft_tolower ===
0 -> ft=0 std=0 [PASS]
13 -> ft=13 std=13 [PASS]
26 -> ft=26 std=26 [PASS]
39 -> ft=39 std=39 [PASS]
52 -> ft=52 std=52 [PASS]
65 -> ft=97 std=97 [PASS]
78 -> ft=110 std=110 [PASS]
91 -> ft=91 std=91 [PASS]
104 -> ft=104 std=104 [PASS]
117 -> ft=117 std=117 [PASS]

=== TESTING ft_strchr ===
ft_strchr -> the char
strchr    -> the char

=== TESTING ft_strrchr ===
ft_strrchr -> a
strrchr    -> a

=== TESTING ft_strncmp ===
Compare 'abc', 'abd', 2 -> 0 vs 0
Compare 'abc', 'abc', 5 -> -1 vs 0

=== TESTING ft_memchr ===
ft_memchr -> 0x7ffed2bba1e5
memchr    -> 0x7ffed2bba1e5

=== TESTING ft_atoi ===
'0' -> ft=0 std=0
'42' -> ft=42 std=42
'  -12' -> ft=-12 std=-12
' +123abc' -> ft=123 std=123
'2147483647' -> ft=2147483647 std=2147483647

=== TESTING ft_memcmp ===
ft_memcmp -> -1
memcmp    -> -1

=== TESTING ft_strnstr ===
ft_strnstr -> World
strnstr    -> World

=== TESTING ft_calloc ===
ft_calloc zeroed? YES

=== TESTING FT_STRDUP ===
=== CASOS NORMALES ===
Test: String vac√≠o
Input: ""
Original: ""
Custom:   ""
Result: ‚úì PASS

Test: String corto
Input: "Hola"
Original: "Hola"
Custom:   "Hola"
Result: ‚úì PASS

Test: String medio
Input: "Hello World!"
Original: "Hello World!"
Custom:   "Hello World!"
Result: ‚úì PASS

Test: String largo
Input: "Esta es una cadena bastante larga para probar la duplicaci√≥n"
Original: "Esta es una cadena bastante larga para probar la duplicaci√≥n"
Custom:   "Esta es una cadena bastante larga para probar la duplicaci√≥n"
Result: ‚úì PASS

=== CARACTERES ESPECIALES ===
Test: Con espacios
Input: "   espacios   "
Original: "   espacios   "
Custom:   "   espacios   "
Result: ‚úì PASS

Test: Con tabs
Input: "		con	tabs	"
Original: "		con	tabs	"
Custom:   "		con	tabs	"
Result: ‚úì PASS

Test: Con newlines
Input: "line1
line2
line3"
Original: "line1
line2
line3"
Custom:   "line1
line2
line3"
Result: ‚úì PASS

Test: Caracteres especiales
Input: "!@#$%^&*()_+-=[]{}|;:,.<>?"
Original: "!@#$%^&*()_+-=[]{}|;:,.<>?"
Custom:   "!@#$%^&*()_+-=[]{}|;:,.<>?"
Result: ‚úì PASS

=== CASOS L√çMITE ===
Test: Un solo car√°cter
Input: "A"
Original: "A"
Custom:   "A"
Result: ‚úì PASS

‚úì PASS - Memoria diferente asignada
=== MANEJO DE ERRORES ===
Test: Entrada NULL
‚úì PASS - Manejo correcto de NULL input

=== TEST DE ESTR√âS ===
‚úì PASS - Duplicaci√≥n en cadena larga correcta
=== ft_strdup tests completed ===

=== TESTING FT_SUBSTR ===
Case 1: expected 'Hello' got 'Hello'
Case 2: expected 'World' got 'World'
Case 3: expected '' got ''
Case 4: start beyond len -> got 'ld'
Case 5: NULL input -> got '(null)'
=== ft_substr tests completed ===

=== Testing ft_strjoin ===
Caso 1: ft_strjoin("Hello", "World") => "HelloWorld"
Caso 2: ft_strjoin("Hello ", "World") => "Hello World"
Caso 3: ft_strjoin(NULL, "World") => NULL
Caso 4: ft_strjoin("Hello", NULL) => NULL
=== ft_strjoin tests completed ===

=== TESTING FT_STRTRIM ===
Test 1 - Espacios: "   Hello World   " -> "Hello World" [OK]
Test 2 - 'x' set: "xx42xx" -> "42"
Test 3 - Set vac√≠o: "Hello" -> "Hello"
Test 4 - Input vac√≠o: "" -> ""
Test 5 - NULL input -> NULL
=== ft_strtrim tests completed ===

=== TESTING FT_SPLIT ===
Test 1 - Split b√°sico: "Hello World Test" -> Result: ["Hello", "World", "Test"]
 [OK]
Test 2 - M√∫ltiples espacios: "Hello   World   Test" -> Result: ["Hello", "World", "Test"]
 [OK]
Test 3 - String vac√≠o: "" -> Result: []
 [OK]
Test 4 - Solo espacios: "     " -> Result: []
 [OK]
Test 5 - Espacios inicio/fin: " Hello World " -> Result: ["Hello", "World"]
 [OK]
Test 6 - NULL string: NULL -> NULL [OK]
Test 7 - Coma delimiter: "apple,banana,cherry" -> Result: ["apple", "banana", "cherry"]
 [OK]
Test 8 - Sin espacios: "Hello" -> Result: ["Hello"]
 [OK]
Test 9 - Asterisco delimiter: "a*b*c*d" -> Result: ["a", "b", "c", "d"]
 [OK]
Test 10 - String largo: "a b c d e f g h i j k l m n o p" -> Array con 16 elementos [OK]
=== TESTING FT_ITOA ===

Test: Zero
  Input: 0
  Original itoa: '0'
  Your ft_itoa:  '0'
  ‚úÖ PASS

Test: Positive single digit
  Input: 1
  Original itoa: '1'
  Your ft_itoa:  '1'
  ‚úÖ PASS

Test: Negative single digit
  Input: -1
  Original itoa: '-1'
  Your ft_itoa:  '-1'
  ‚úÖ PASS

Test: Small positive
  Input: 42
  Original itoa: '42'
  Your ft_itoa:  '42'
  ‚úÖ PASS

Test: Small negative
  Input: -42
  Original itoa: '-42'
  Your ft_itoa:  '-42'
  ‚úÖ PASS

Test: Medium positive
  Input: 123
  Original itoa: '123'
  Your ft_itoa:  '123'
  ‚úÖ PASS

Test: Medium negative
  Input: -123
  Original itoa: '-123'
  Your ft_itoa:  '-123'
  ‚úÖ PASS

Test: Round number positive
  Input: 1000
  Original itoa: '1000'
  Your ft_itoa:  '1000'
  ‚úÖ PASS

Test: Round number negative
  Input: -1000
  Original itoa: '-1000'
  Your ft_itoa:  '-1000'
  ‚úÖ PASS

Test: INT_MAX
  Input: 2147483647
  Original itoa: '2147483647'
  Your ft_itoa:  '2147483647'
  ‚úÖ PASS

Test: INT_MIN
  Input: -2147483648
  Original itoa: '-2147483648'
  Your ft_itoa:  '-2147483648'
  ‚úÖ PASS

Test: Single digit max
  Input: 9
  Original itoa: '9'
  Your ft_itoa:  '9'
  ‚úÖ PASS

Test: Single digit min
  Input: -9
  Original itoa: '-9'
  Your ft_itoa:  '-9'
  ‚úÖ PASS

Test: Two digits start
  Input: 10
  Original itoa: '10'
  Your ft_itoa:  '10'
  ‚úÖ PASS

Test: Two digits negative start
  Input: -10
  Original itoa: '-10'
  Your ft_itoa:  '-10'
  ‚úÖ PASS

Test: Two digits max
  Input: 99
  Original itoa: '99'
  Your ft_itoa:  '99'
  ‚úÖ PASS

Test: Two digits min
  Input: -99
  Original itoa: '-99'
  Your ft_itoa:  '-99'
  ‚úÖ PASS

Test: Three digits start
  Input: 100
  Original itoa: '100'
  Your ft_itoa:  '100'
  ‚úÖ PASS

Test: Three digits negative start
  Input: -100
  Original itoa: '-100'
  Your ft_itoa:  '-100'
  ‚úÖ PASS

Test: With zeros inside
  Input: 1001
  Original itoa: '1001'
  Your ft_itoa:  '1001'
  ‚úÖ PASS

Test: With zeros inside negative
  Input: -1001
  Original itoa: '-1001'
  Your ft_itoa:  '-1001'
  ‚úÖ PASS

Test: Large number
  Input: 1000000
  Original itoa: '1000000'
  Your ft_itoa:  '1000000'
  ‚úÖ PASS

Test: Large negative number
  Input: -1000000
  Original itoa: '-1000000'
  Your ft_itoa:  '-1000000'
  ‚úÖ PASS

Test: Max int exact
  Input: 2147483647
  Original itoa: '2147483647'
  Your ft_itoa:  '2147483647'
  ‚úÖ PASS

Test: Almost min int
  Input: -2147483647
  Original itoa: '-2147483647'
  Your ft_itoa:  '-2147483647'
  ‚úÖ PASS

=== TESTS COMPLETED ===

=== COMPREHENSIVE FT_STRMAPI TESTING ===

=== TESTING FT_STRMAPI EDGE CASES ===
Test: Empty string
  Input: ""
  Expected: ""
  Got:      ""
  Result: ‚úÖ PASS

Test: NULL string input
  Input: NULL
  Got: NULL
  Result: ‚úÖ PASS

Test: NULL function input
  Input: 'test' with NULL function
  Got: NULL
  Result: ‚úÖ PASS

Test: Both inputs NULL
  Input: NULL, NULL
  Got: NULL
  Result: ‚úÖ PASS


=== TESTING FT_STRMAPI NORMAL CASES ===
Test: To upper even positions
  Input: "hello"
  Expected: "HeLlO"
  Got:      "HeLlO"
  Result: ‚úÖ PASS

Test: Spaces with rotation
  Input: "abc"
  Expected: "ace"
  Got:      "ace"
  Result: ‚úÖ PASS

Test: Special characters
  Input: "a!b@c#"
  Expected: "a!c@e#"
  Got:      "a!d@g#"
  Result: ‚ùå FAIL

Test: Long string
  Input: "abcdefghij"
  Expected: "AbCdEfGhIj"
  Got:      "AbCdEfGhIj"
  Result: ‚úÖ PASS

Test: Single char
  Input: "a"
  Expected: "A"
  Got:      "A"
  Result: ‚úÖ PASS

Test: Identity function
  Input: "Hello World!"
  Expected: "Hello World!"
  Got:      "Hello World!"
  Result: ‚úÖ PASS


=== TESTING FT_STRMAPI COMPLEX CASES ===
Test: Position digits
  Input: "xxxxx"
  Expected: "01234"
  Got:      "01234"
  Result: ‚úÖ PASS

Test: Alternate XY
  Input: "hello"
  Expected: "XYXYX"
  Got:      "XYXYX"
  Result: ‚úÖ PASS

Test: Numbers identity
  Input: "12345"
  Got: "12345"
  Result: ‚úÖ PASS

Test: ASCII codes
  Input: "ABC"
  Got: "ABC"
  Result: ‚ùå FAIL


=== TESTING FT_STRMAPI MEMORY BEHAVIOR ===
‚úÖ PASS - Memory is properly allocated (different addresses)
  Original: 0x55ad1f7281e7
  Result:   0x55ad4381c380
Result: ‚úÖ PASS - Original unchanged

=== FT_STRMAPI TESTS COMPLETED ===

=== COMPREHENSIVE FT_STRITERI TESTING ===

=== TESTING FT_STRITERI EDGE CASES ===
Test: Empty string
  Input:    ""
  Expected: ""
  Got:      ""
  Result: ‚úÖ PASS

Test: NULL string input
  Input: NULL
  Result: ‚úÖ PASS (no crash)

Test: NULL function input
  Input: 'test' with NULL function
  Result: ‚úÖ PASS (unchanged)

Test: Both inputs NULL
  Input: NULL, NULL
  Result: ‚úÖ PASS (no crash)


=== TESTING FT_STRITERI NORMAL CASES ===
Test: To upper even positions
  Input:    "hello"
  Expected: "HeLlO"
  Got:      "HeLlO"
  Result: ‚úÖ PASS

Test: Character rotation
  Input:    "abc"
  Expected: "ace"
  Got:      "ace"
  Result: ‚úÖ PASS

Test: Special characters with rotation
  Input:    "a!b@c#"
  Expected: "a!c@e#"
  Got:      "a!d@g#"
  Result: ‚ùå FAIL

Test: Long string with upper even
  Input:    "abcdefghij"
  Expected: "AbCdEfGhIj"
  Got:      "AbCdEfGhIj"
  Result: ‚úÖ PASS

Test: Single char to upper
  Input:    "a"
  Expected: "A"
  Got:      "A"
  Result: ‚úÖ PASS

Test: Numbers with rotation
  Input:    "12345"
  Expected: "12345"
  Got:      "12345"
  Result: ‚úÖ PASS


=== TESTING FT_STRITERI COMPLEX CASES ===
Test: Position digits replacement
  Input:    "xxxxx"
  Expected: "01234"
  Got:      "01234"
  Result: ‚úÖ PASS

Test: Alternate XY replacement
  Input:    "hello"
  Expected: "XYXYX"
  Got:      "XYXYX"
  Result: ‚úÖ PASS

Test: Increment ASCII chars
  Input:    "ABC"
  Expected: "BCD"
  Got:      "BCD"
  Result: ‚úÖ PASS

Test: Mixed case with upper even
  Input:    "AbCdEf"
  Expected: "AbCdEf"
  Got:      "AbCdEf"
  Result: ‚úÖ PASS

Test: Alphabet boundaries with rotation
  Input:    "xyz"
  Expected: "xzb"
  Got:      "xzb"
  Result: ‚úÖ PASS

Test: Multiple sequential transformations
  Original: "hello"
  After upper even: "HeLlO"
  Result: ‚úÖ PASS


=== TESTING FT_STRITERI MODIFICATION BEHAVIOR ===
Test: In-place modification
  Before: "test" at 0x55ad4381c380
  After:  "TeSt" at 0x55ad43A! 
	~ÄˇSTDOUTHola Mundo   espacios   L√≠nea1
L√≠nea2	TabuladoABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUTexto con	tabulaci√≥n
ynueva l√≠neaASCII: ~ÄˇEspa√±ol: √±√°√©√≠√≥√∫Este texto va a stdout81c380
  Result: ‚úÖ PASS (same address, modified)

Test: Reusability after modification
  Original: "hello world"
  After first mod: "HeLlO WoRlD"
  After second mod: "IfMmP!XpSmE"
  Result: ‚úÖ PASS (multiple modifications work)


=== TESTING FT_STRITERI MEMORY SAFETY ===
Test: Memory after null terminator integrity
  Before: buffer='hello', after_null='SAFE'
  After:  buffer='HeLlO', after_null='SAFE'
  Result: ‚úÖ PASS (memory intact)

Test: Exact buffer size
  Before: 'hello'
  After:  'ifmmp'
  Result: ‚úÖ PASS (no buffer overflow)


=== TESTING FT_STRITERI PERFORMANCE CASES ===
Test: Very long string
  Length: 999 characters
  Result: ‚úÖ PASS (all processed)

=== FT_STRITERI TESTS COMPLETED ===

=== TEST COMPLETO FT_PUTCHAR_FD ===

=== TESTING FT_PUTCHAR_FD - CASOS B√ÅSICOS ===
Test 1: Car√°cter 'A' en stdout
 <- Deber√≠a ver 'A' antes de este texto
Test 2: Car√°cter '7' en stderr
 <- Deber√≠a ver '7' antes de este texto (en stderr)
Test 3: Car√°cter '!' en stdout
 <- Deber√≠a ver '!' antes de este texto

=== TESTING FT_PUTCHAR_FD - CASOS L√çMITE ===
Test 1: Car√°cter nulo (\0)
 <- Si no ves nada antes, es correcto (car√°cter nulo)
Test 2: Nueva l√≠nea
Antes -><- Despu√©s
Test 3: Tabulaci√≥n
Inicio||Fin

=== TESTING FT_PUTCHAR_FD - OPERACIONES CON ARCHIVOS ===
Contenido del archivo: 'Hola
' ‚úÖ PASS

=== TESTING FT_PUTCHAR_FD - CARACTERES ESPECIALES ===
Test 1: Caracteres de control ASCII
Campana (\a): 
Retroceso (\b): 
Retorno de carro (\r):  (cursor al inicio)
Test 2: Caracteres ASCII extendidos
ASCII 126: 
ASCII 127: 

=== TESTING FT_PUTCHAR_FD - CASOS DE ERROR ===
Test 1: File descriptor -1
 <- No deber√≠a crash (manejo silencioso de error)
Test 2: File descriptor 999 (probablemente no existente)
 <- No deber√≠a crash
Test 3: File descriptor cerrado
 <- File descriptor cerrado - no deber√≠a crash

=== TESTING FT_PUTCHAR_FD - L√çMITES UNICODE/CHAR ===
Test 1: L√≠mites de char
Char 127: 
Char -128:  (comportamiento indefinido, pero no deber√≠a crash)
Test 2: Valores fuera de rango
Char 255:  (comportamiento dependiente del sistema)

=== TESTING FT_PUTCHAR_FD - M√öLTIPLES LLAMADAS ===
Resultado m√∫ltiples llamadas: 'MultipleTest
' ‚úÖ PASS

=== TESTING FT_PUTCHAR_FD - STDOUT vs STDERR ===
Escribiendo en stdout (fd 1): 
Escribiendo en stderr (fd 2):  (puede verse igual o diferente seg√∫n la terminal)

=== TESTS FT_PUTCHAR_FD COMPLETADOS ===

=== TEST COMPLETO FT_PUTSTR_FD ===

=== TESTING FT_PUTSTR_FD - CASOS B√ÅSICOS ===
Test 1: String 'Hola Mundo' en stdout
Salida: 
Test 2: String vac√≠o ''
Salida: '' (deber√≠a ser vac√≠o)
Test 3: String con espacios
Salida: 

=== TESTING FT_PUTSTR_FD - CASOS L√çMITE ===
Test 1: String NULL
Salida:  (no deber√≠a crash, posiblemente nada o comportamiento definido)
Test 2: String con caracteres especiales
Salida: 
Test 3: String largo
Salida (primeros 50 chars): 

=== TESTING FT_PUTSTR_FD - OPERACIONES CON ARCHIVOS ===
Contenido del archivo:
Primera l√≠nea
Segunda l√≠nea
Tercera l√≠nea con n√∫mero: 42
‚úÖ PASS - Contenido correcto

=== TESTING FT_PUTSTR_FD - CARACTERES ESPECIALES ===
Test 1: String con caracteres de control
Salida:  (fin del test)
Test 2: Caracteres ASCII extendidos
Salida: 
Test 3: Caracteres UTF-8
Salida: 

=== TESTING FT_PUTSTR_FD - CASOS DE ERROR ===
Test 1: File descriptor -1
 <- No deber√≠a crash
Test 2: File descriptor 999
 <- No deber√≠a crash
Test 3: String NULL con fd 1
 <- Comportamiento con NULL
Test 4: File descriptor de solo lectura
 <- Escritura en fd de solo lectura

=== TESTING FT_PUTSTR_FD - M√öLTIPLES STRINGS ===
Contenido del archivo:
String 1
String 2
String 3
Final del archivo
‚úÖ PASS - M√∫ltiples strings correctos

=== TESTING FT_PUTSTR_FD - STDOUT vs STDERR ===
Escribiendo en stdout (fd 1): 
Escribiendo en stderr (fd 2):  (puede verse diferente en algunas terminales)

=== TESTING FT_PUTSTR_FD - RENDIMIENTO ===
Escribiendo string de 10000 caracteres...
‚úÖ PASS - String grande escrito sin crash

=== TESTING FT_PUTSTR_FD - FORMATEO ===
Archivo formateado:
=== INICIO DEL ARCHIVO ===
L√≠nea 1: Valor = 42
L√≠nea 2: Texto con	tabulaci√≥n
L√≠neaHola Mundo

   espacios   

Texto con	tabulaci√≥n
ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTU
Texto con newline

L√≠nea1
L√≠nea2
L√≠nea3
Espa√±ol: √±√°√©√≠√≥√∫

Esta l√≠nea va a stdout
Otra l√≠nea en stdout
042123-1-42-1232147483647-21474836481001000100000123456789-9-8-7-6-5-4-3-2-1123456789987654321 3: Caracteres ~!@#$%^&*()
=== FIN DEL ARCHIVO ===
‚úÖ PASS - Formateo correcto

=== TESTS FT_PUTSTR_FD COMPLETADOS ===

=== TEST COMPLETO FT_PUTENDL_FD ===

=== TESTING FT_PUTENDL_FD - CASOS B√ÅSICOS ===
Test 1: String 'Hola Mundo' en stdout
Salida esperada: 'Hola Mundo' seguido de nueva l√≠nea
Salida real: (deber√≠a estar en la l√≠nea siguiente)
Test 2: String vac√≠o ''
Salida: '' (deber√≠a ser solo nueva l√≠nea)
Test 3: String con espacios
Salida: (nueva l√≠nea autom√°tica)

=== TESTING FT_PUTENDL_FD - CASOS L√çMITE ===
Test 1: String NULL
Salida:  (comportamiento con NULL - posiblemente nueva l√≠nea o nada)
Test 2: String con caracteres especiales
Salida: (deber√≠a tener nueva l√≠nea)
Test 3: String largo
Salida: (string largo + nueva l√≠nea)

=== TESTING FT_PUTENDL_FD - OPERACIONES CON ARCHIVOS ===
Contenido del archivo:
Primera l√≠nea
Segunda l√≠nea
Tercera l√≠nea con n√∫mero: 42

√öltima l√≠nea
‚ùå FAIL - Se esperaban 5 l√≠neas, se encontraron 4

=== TESTING FT_PUTENDL_FD vs FT_PUTSTR_FD ===
putendl_fd produjo: 'L√≠nea con putendl
'
putstr_fd + putchar_fd produjo: 'L√≠nea con putstr
'
‚ùå FAIL - Los resultados son diferentes

=== TESTING FT_PUTENDL_FD - CARACTERES ESPECIALES ===
Test 1: String que ya termina con \n
Salida: (deber√≠a tener nueva l√≠nea extra)
Test 2: String con m√∫ltiples newlines
Salida: (nueva l√≠nea adicional al final)
Test 3: Caracteres UTF-8
Salida: (caracteres especiales + nueva l√≠nea)

=== TESTING FT_PUTENDL_FD - CASOS DE ERROR ===
Test 1: File descriptor -1
 <- No deber√≠a crash
Test 2: File descriptor 999
 <- No deber√≠a crash
Test 3: String NULL con fd 1
 <- Comportamiento con NULL
Test 4: String NULL con fd 2
 <- Comportamiento con NULL en stderr

=== TESTING FT_PUTENDL_FD - M√öLTIPLES L√çNEAS ===
Contenido del archivo:
L√≠nea 1 del archivo
L√≠nea 2 con algunos datos
L√≠nea 3: valor = 123

√öltima l√≠nea del archivo
‚úÖ PASS - 5 l√≠neas correctamente escritas

=== TESTING FT_PUTENDL_FD - STDOUT vs STDERR ===
Escribiendo en stdout (fd 1):
Escribiendo en stderr (fd 2):
(pueden verse igual o diferente seg√∫n la terminal)

=== TESTING FT_PUTENDL_FD - FORMATEO COMPLEJO ===
Archivo de log creado:
=== INICIO DEL LOG ===

TIMESTAMP: 2024-01-01 12:00:00
LEVEL: INFO
MESSAGE: Sistema iniciado correctamente

TIMESTAMP: 2024-01-01 12:00:05
LEVEL: WARNING
MESSAGE: Configuraci√≥n por defecto cargada

=== FIN DEL LOG ===
‚úÖ PASS - Formato de log correcto con l√≠neas vac√≠as

=== TESTING FT_PUTENDL_FD - RENDIMIENTO ===
Escribiendo 100 l√≠neas...
L√≠neas escritas: 100, L√≠neas le√≠das: 100
‚úÖ PASS - Todas las l√≠neas escritas correctamente

=== TESTS FT_PUTENDL_FD COMPLETADOS ===

=== TEST COMPLETO FT_PUTNBR_FD ===

=== TESTING FT_PUTNBR_FD - CASOS B√ÅSICOS ===
Test 1: N√∫meros positivos
Salida:  (deber√≠a ser '0')
Salida:  (deber√≠a ser '42')
Salida:  (deber√≠a ser '123')
Test 2: N√∫meros negativos
Salida:  (deber√≠a ser '-1')
Salida:  (deber√≠a ser '-42')
Salida:  (deber√≠a ser '-123')

=== TESTING FT_PUTNBR_FD - CASOS L√çMITE ===
Test 1: L√≠mites de int
Salida:  (deber√≠a ser '2147483647')
Salida:  (deber√≠a ser '-2147483648')
Test 2: N√∫meros con ceros
Salida:  (deber√≠a ser '100')
Salida:  (deber√≠a ser '1000')
Salida:  (deber√≠a ser '10000')

=== TESTING FT_PUTNBR_FD - OPERACIONES CON ARCHIVOS ===
Contenido del archivo:
0
42
-123
2147483647
-2147483648
‚úÖ PASS - Todos los n√∫meros escritos correctamente

=== TESTING FT_PUTNBR_FD - N√öMEROS ESPECIALES ===
Test 1: D√≠gitos individuales
Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  
Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  Salida:  
Test 3: N√∫meros con patrones
Salida:  (deber√≠a ser '123456789')
Salida:  (deber√≠a ser '987654321')

=== TESTING FT_PUTNBR_FD - CASOS DE ERROR ===
Test 1: File descriptor -1
 <- No deber√≠a crash
Test 2: File descriptor 999
 <- No deber√≠a crash
Test 3: File descriptor de solo lectura
 <- Escritura en fd de solo lectura

=== TESTING FT_PUTNBR_FD - M√öLTIPLES N√öMEROS ===
Contenido del archivo: 1, -2, 3, -4, 5, -6, 7, -8, 9, -10, 100, -1000, 123123452147483646-21474836471000000000-10000000000101100110001-100145, -67890
‚úÖ PASS - Secuencia de n√∫meros correcta

=== TESTING FT_PUTNBR_FD - STDOUT vs STDERR ===
Escribiendo en stdout (fd 1): 
Escribiendo en stderr (fd 2):  (puede verse diferente en algunas terminales)

=== TESTING FT_PUTNBR_FD - N√öMEROS GRANDES ===
Test 1: N√∫meros cerca de INT_MAX
Salida:  (deber√≠a ser '2147483646')
Salida:  (deber√≠a ser '-2147483647')
Test 2: N√∫meros con muchos d√≠gitos
Salida:  (deber√≠a ser '1000000000')
Salida:  (deber√≠a ser '-1000000000')

=== TESTING FT_PUTNBR_FD - MANEJO DE CEROS ===
Test 1: Cero simple
Salida:  (deber√≠a ser '0')
Test 2: N√∫meros que contienen ceros
Salida:  (deber√≠a ser '101')
Salida:  (deber√≠a ser '1001')
Salida:  (deber√≠a ser '10001')
Salida:  (deber√≠a ser '-1001')

=== TESTING FT_PUTNBR_FD - RENDIMIENTO ===
Escribiendo 50 n√∫meros...
L√≠neas escritas: 100 (esperado: 100)
‚úÖ PASS - Todos los n√∫meros escritos correctamente

=== TESTING FT_PUTNBR_FD vs FT_ITOA ===
putnbr_fd produjo:
0
42
-123
2147483647
-2147483648
1001
-9999

itoa + putstr_fd produjo:
0
42
-123
2147483647
-2147483648
1001
-9999

‚úÖ PASS - Ambas approaches producen el mismo resultado

=== TESTS FT_PUTNBR_FD COMPLETADOS ===

=== TESTING COMPLETE ===
